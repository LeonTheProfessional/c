### 0. 导读

1. 有关心智模式：
	- 《第五项修炼——学习型组织的艺术与实务》
	- 《心灵的科学》

2. 数组下标：
	```
	int i;
	int a[N];
	for (i=0; i <= N; i++)
	    a[i] = 0;
	``` 
在很多C编译器中，它将会陷入一个死循环。
因为在栈中，a[N]所指内存单元就是变量i的地址，最后一次又将i重置为0，导致死循环。
ANSI C标准允许程序得到数组尾端出界的第一个位置的地址。

### 1. 词法“陷阱”

1. 一般而言，赋值运算符相对于比较运算符出现得更频繁，因此字符数较少的符号=就被赋予了更常用的含义——赋值操作。

2. 词法分析中的“贪心法”：每一个符号应该包含尽可能多的字符。

3. 用单引号引起的一个字符实际上代表一个整数。用双引号引起的字符串，代表一个指向无名数组起始字符的指针。

4. 整数的存储空间可以容纳多个字符，有的C编译器允许在一个字符常量中包含多个字符。Visual C++ 6.0和GCC v2.95中采取的做法是：依次用后一个字符覆盖前一个字符，最后得到的整数值即最后一个字符的整数值。

5. 允许嵌套注释和不允许嵌套注释都合法的字符序列：
	- `/*/**/"*/"/*"/**/`
	允许嵌套：`"/*"`
	不允许嵌套：`"*/"`
	- `/*/*/0*/**/1`
	允许嵌套：`1`
	不允许嵌套：`0*1`
	
### 2. 语法“陷阱”

1. 函数声明：
(* (void (*) ()) 0) ();
调用地址为0的函数

2. 运算符优先级：
单目运算符、赋值运算符、条件运算符(三目运算符)自右至左结合。
（数组下标、函数调用操作符、结构成员选择操作符） >  单目运算符  >  算术运算符  >  移位运算符  >  关系运算符  >  逻辑运算符  >  条件运算符  >  赋值运算符  >  逗号运算符

3. 注意作为语句结束标志的分号：
(1)在if或者while语句之后需要紧跟一条语句时，如果此时多了一个分号，那么原来紧跟在if或while子句之后的语句就成了一条单独的语句，与条件判断部分没有了任何关系。如：
if (x[i] > big);
    big = x[i];
(2)如果遗漏了一个分号。如return后的分号被遗漏：
if (n < 3)
    return
logrec.date = x[0];
logrec.time = x[1];
logrec.code = x[2];
如果一个函数不需要返回值(即返回值为void)，经常在函数声明时省略了返回值类型，但是此时编译器会隐含地将函数返回值类型视作int类型。
(3)当一个声明的结尾紧跟一个函数定义时，如果声明结尾的分号被省略，编译器可能会把声明的类型视作函数的返回值类型。如：
struct logrec {
    int date;
    int time;
    int code;
}
main ()
{
    ……
}

### 3. 语义“陷阱”

1. 指针与数组
(1) C语言中只有一维数组，而且数组的大小必须在编译期就作为一个常数确定下来。
(2) 对于一个数组，我们只能做两件事：确定该数组的大小，以及获得指向该数组下标为0的元素的指针。其他有关数组的操作，都是通过指针进行的。数组名就是数组第一个元素指针。
(3) `int * ip;`给指针ip加1，则ip+1指向的是计算机内存中的下一个整数，而不是ip所指向地址的下一个内存位置。
(4) 如果两个指针指向的是同一个数组中的元素，则可以把两个指针相减。
(5) 指向数组的指针：
	
	```
	int a[12][31];
	int (*b) [31];
	b = a;
	b是一个指向数组的指针
	```

2. 复制指针并不同时复制指针所指向的数据。

3. 空指针并非空字符串
编译器保证由0转换而来的指针不等于任何有效的指针。常数0通常用NULL来表示。当常数0被转换为指针时，这个指针绝对不能用来被解引用。即将0赋值给一个指针变量时，不能企图使用该指针所指向的内存中存储的内容。
`if (p == (char *) 0)`合法；
`if (strcmp(p, (char *) 0) == 0)`不合法。因为strcmp库函数的实现中会包括查看它的指针参数所指向内存中的内容的操作。

4. 边界计算与不对称边界
左闭右开：用第一个入界点和第一个出界点来表示一个数值范围。下界是“入界点”，包括在取值范围中；而上界是“出界点”，不包括在取值范围中。那么有：
(1)取值范围的大小就是上界与下界之差。
(2)如果取值范围为空，那么上界等于下界。
(3)即使取值范围为空，上界也不可能小于下界。
注：数组中实际不存在的“溢界”元素的地址位于数组所占内存之后，该地址可用于进行赋值和比较，但是不能引用该地址元素。

5. 求值顺序
C语言中只有四个运算符**(&&、||、?:、,)**存在规定的求值顺序。逗号运算符，首先对左侧操作数求值，然后该值被“丢弃”，再对右侧操作数求值（分隔函数参数的逗号并非逗号运算符）。C语言中其他运算符对其操作数求值的顺序是未定义的。赋值运算符并不保证任何求值顺序。

6. 运算符&&、||和！
	- 按位运算符&、| 和～对操作数的处理方式：将其视为一个二进制的位序列，分别对其每个位进行操作。
	- 逻辑运算符&&、||和！对操作数的处理方式是将其视作要么是真，要么是假，只可能返回0或1。

7. 整数溢出
当两个操作数都是有符号整数时，可能发生“溢出”。“溢出”的结果是未定义的，这时作任何假设都是不安全的，如假设两个正数相加溢出后结果为负数。
	
	```
	//假设a和b是两个非负整型变量，若要检查a+b是否会溢出，一种想当然的方式是：
	if (a + b < 0)
		complain();//但这并不能正常运行
	//一种正确的方式：将a和b都强制转换为无符号整数
	if ((unsigned int)a + (unsigned int)b > INT_MAX)
	{
		complain();
	}
	//注：INT_MAX是一个已定义常量，代表可能的最大整数值。ANSI C标准在<limits.h>中定义了INT_MAX
	//或者采用另一种可行方法：
	if (a > ING_MAX - b)
	{
		complain();
	}		
	```

9. 为函数main提供返回值
	```
	main()
	{
	......
	}
	//如果并未显式声明返回类型，函数返回类型默认为整型。但是此处没有任何返回值
	```

### 4. 连接

1. 