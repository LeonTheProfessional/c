## 第1章 概览 ##

### 1. 使用C语言的7个步骤 ###

1. 定义程序目标

2. 设计程序

3. 编写代码

4. 编译

5. 运行程序

6. 测试和调试程序

7. 维护和修改程序 

### 2. 编译器和链接器的作用 ###

1. **编译器**：把源代码转换成机器语言代码，即目标代码

2. **链接器**：把多个来源（例如，已编译的源代码、库代码和启动代码）的目标代码连接成一个单独的可执行程序

## 第2章 C语言概述 ##

1. C99标准允许一个标识符最多可以有**63**个字符

2. 操作系统和C库通常使用以一个或两个下划线开始的名字

3. 转义字符：通常用于代表难于表达的或是无法键入的字符

4. **程序状态**(program state)：指在程序执行过程中给定点上所有变量值的集合

## 第3章 数据和C ##

### 1. 数据类型关键字

1. 数据类型按其在计算机中的存储方式被划分为两个系列：整数类型和浮点类型

2. 最小的存储单位称为**位**，位是计算机存储的基本单位，字是自然的存储单位

3. 浮点数往往只是实际值的近似 

### 2. C数据类型

1. C的各种整数类型的区别在于所提供数值的范围，以及数值是否可以取负值

2. 系统通过使用一个指示正负符号的特定位来表示有符号整数

3. 最好避免在一个声明语句中同时出现初始化和未初始化的变量，如`int dogs, cats = 94;`

4. %d被称为格式说明符，必须确保格式说明符的数目同待打印值的数目相同，编译器不会发现这类错误；C通过一种函数原型机制检查函数调用是否使用了正确数目及类型的参数，但这对参数数目可变的printf()和scanf()不起作用

5. 前缀0x或者0X表示使用十六进制，前缀0表示使用八进制；**%o**用于显示八进制整数,**%x**用于显示十六进制；可以使用说明符**%#o**、**%#x**和**%#X**分别生成前缀0、0x和0X

6. C99增加了**unsigned long long int**（简写为unsigned long long）类型

7. 为了适应不同机器，C仅保证short类型不会比int类型长，并且long类型不会比int类型短

8. 在long类型大于int类型的系统中，使用long类型会减慢计算

9. 建议使用L后缀显式标识long类型值，使用LL后缀显式标识long long类型值

10. **%ho**表示以八进制显式short整数

11. C将字符常量视为int类型而非char类型，如`char grade = 'B'`，这里'B'作为数值存储在一个32位单元中，而赋值后的grade则把66存储在一个8位单元中，利用这种特性，可以定义一个字符常量'FATE'，这将把4个独立的8位ASCII码存储在一个32位单元中，若把该字符常量赋值给一个char变量，那么变量值位'E'

12. 在ASCII码和转义序列之间优先选择使用转义序列；当需要使用数值编码时，应使用'\032'而非032，因为'\032'这样的转义序列可以嵌入到C字符串中

13. 浮点常量最基本的形式：包含一个小数点的一个带符号的数字序列，接着是字母e或E，然后是代表10的指数的一个有符号值

14. 在浮点常量中不要使用空格，如`1.56 E+12`；可以通过f或F后缀使编译器把浮点常量当作float类型，没有后缀的浮点常量默认为double类型

15. printf()函数使用**%f**格式说明符打印十进制计数法的float和double数字，用**%e**打印指数计数法的数字；打印long double类型需要用**%Lf**、**%Le**和**%La**说明符

16. 未在原型中显式说明参数类型的函数（如printf()）传递参数时，C自动将float类型的参数转换为double类型

### 3. 参数和易犯的错误

1. 使用**%d**显示float值不会把该float值转换为近似的int值，而是显示垃圾值；使用**%f**显示int值也不会把该int值转换为浮点值，同样显示垃圾值 

### 4. 刷新输出

1. 标准C规定以下几种情况会将缓冲区内容传给屏幕：缓冲区满、遇到换行符、需要输入的时候；除此之外，使用fflush()函数也可以刷新输出缓冲区

## 第4章 字符串和格式化输入/输出

### 1. 字符串简介

1. **\0**表示空字符，C用它来标记字符串的结束；空字符不是数字0，是非打印字符，其ASCII码值为0

2. scanf()读取输入时在遇到第一个空白字符空格、制表符或者换行符时停止读取

3. strlen()函数以字符为单位计算字符串的长度，字符串结束符'\0'不计算在内

4. 一些ANSI之前的UNIX系统使用头文件strings.h而非string.h

5. sizeof运算符把标识字符串结束的不可见的空字符'\0'也计算在内；sizeof是否使用圆括号取决于是想获取一个类型的大小还是想获取某个具体量的大小；圆括号对于类型是必需的，而对于具体量则是可选的，但建议都使用圆括号，如：`sizeof(char)`、`sizeof(6.28)` 

### 2. printf()和scanf()

1. printf()函数的转换说明符及作为结果的打印输出
	
	**%a** / **%A**：浮点数、十六进制数字和p-计数法(C99)	
	**%g** / **%G**：根据数值不同自动选择**%f**或**%e**	
	**%p**：指针 	
 	**%%**：打印一个百分号
 	
2. printf()和其他任何不使用显式原型的C函数的所有float参数会自动被转换成double

3. 不匹配的浮点数转换，如下所示:
	```
    #include <stdio.h>
    int main(void)
    {
        float n1 = 3.0;
        double n2 = 3.0;
        long n3 = 2000000000;
        long n4 = 1234567890;
    
        printf("%.1e %.1e %.1e %.1e\n", n1, n2, n3, n4);
        printf("%ld %ld\n", n3, n4);
        printf("%ld %ld %ld %ld\n", n1, n2, n3, n4);
    
        return 0;
    }
    结果如下：
    3.0e+00 3.0e+00 3.1e+46 2.2e-314
    2000000000 1234567890
    0 1074266112 0 1074266112
	```
	由上可见，程序试图使用**%ld**打印一个long类型居然也失败了,因为printf()一次按格式说明符从栈顶取出相应大小的数据，详情请查看P75-76

4. printf()函数的返回值表示打印字符的数目(统计字符数目时，针对所有的打印字符，包括空格和不可见的换行字符)，如果输出有错误，那么printf()返回一个负数

5.  当一行代码太长需要换行时，如果使用'\'，则下一行必须从行的最左边开始

6. 参数：printf()使用变量名、常量和表达式；scanf()使用指向变量的指针

7. printf()把**%f**、**%e**、**%E**、**%g**和**%G**同时用于float类型和double类型，而scanf()只把它们用于float类型，而用于double类型时要求使用**l**修饰

8. scanf()读取时持续读取和保存字符直到它遇到第一个非数字的字符，scanf()把这个非数字字符放回输入缓冲

9. 当scanf()把字符串存放在一个指定的数组中时，会添加终止符**'\0'**

10. scanf()格式字符串中的常规字符，如：`scanf("%d, %d", &n, &m);`则在输入时第一个数字后必须紧跟着输入一个逗号

11. scanf()格式字符串中的空格意味着跳过下一个输入项之前的任何空格(包括没有空格);如果在格式字符串中**%c**之前有一个空格，那么scanf()会跳到第一个非空白字符处

12. scanf()返回成功读入的项目的个数；若没有任何读入，返回0；若检测到文件结尾，返回**EOF**

13. printf()和scanf()的**\***修饰符：对于printf()必须使用一个参数来告诉函数该**\***是什么；对于scanf()，当**\***放在**%**和说明符字母之间时，是函数跳过相应的输入项目,比如可用于读取一个文件中某个特定的列 

## 第5章 运算符、表达式和语句
 
### 1. 基本运算符

1. 数据对象、左值、右值和操作数
	
	**a.** 数据对象：泛指数据存储区	
	**b.** 左值：用于标识一个特定的数据对象的名字或表达式	
	**c.** 右值：能赋值给可修改的左值的量	
	**d.** 操作数：运算符操作的对象

2. C90标准将一元 **+** 运算符加进了C中，该运算符**不改变它的操作数的值或符号**

3. 在C中，整数除法结果的小数部分被丢弃，称为**截尾**

4. 运算符的结合性只适用于共享同一操作数的运算符

### 2. 其他运算符

1. **sizeof**运算符以字节为单位返回其操作数的大小；该操作数可以是一个具体的数据对象，或者一个类型；如果它是一个类型，操作数必须被括在圆括号内；通常应使用圆括号将操作数括起来

2. 取模运算只针对整数而言，负数取模，结果的符号由第一个操作数的符号决定

3. 在同一个位置执行循环的判断和循环的改变可以防止忘记更新循环而导致死循环，如**`while (count++ < 10)`**

4. 增量运算符 **++** 通常能产生更高效的机器语言代码

5. 避免使用前缀形式和后缀形式将导致不同效果的代码，如不要使用 **`b = ++i;`** 而应使用 **`++i; b =i;`** 来代替

6. 增量运算符和减量运算符只能影响一个变量，如 **`(x * y)++`** 是无效的

7. 在C中编译器可以选择优先计算函数里的哪个参数的值

8. 使用自增自减运算符时应当注意：
	
	**a.** 如果一个变量出现在同一个函数的多个参数中时，不要将增量或者减量运算符用于该变量	
	**b.** 当一个变量多次出现在一个表达式里时，不要将增量或者减量运算符运用于该变量
 
### 3. 表达式和语句

1. **程序**：一系列带有某种必需的标点的语句的集合

2. 一个语句是一条完整的指令，但不是所有完整的指令都是语句，如 **`x = 6 + (y = 5);`** **y = 5**是一个完整的指令，但不是一个语句

3. **副作用**：对数据对象或文件的修改

4. **顺序点**：程序中执行的一点，所有的副作用都在进入下一步之前被计算

5. **复合语句**：使用花括号组织起来的两个或更多的语句

### 4. 类型转换

1. 类型转换的基本规则：
	
	**a.** 当出现在表达式里，有符号和无符号的char和short类型都将自动被转换为int，在需要的时候，将自动转换为unsigned int(如果short与int有相同的大小，那么unsigned short比int大，这时将把unsigned short转换为unsigned int)	
	**b.** 在包含两种数据类型的任何运算里，两个值都将被转换为两种类型里较高的级别	
	**c.** 类型级别从高到低的顺序：long double, double, float, unsigned long long, long long, unsigned long, long, unsigned int; (注：当long和int具有相同大小时，unsigned int 比 long 的级别更高)	
	**d.** 在赋值语句里，计算的最后结果被转换成将被赋予值的那个变量的类型	
	**e.** 当作为函数的参数被传递时，char和short会被转换为int，float会被转换成double

2. 指派运算符：**(type)**，如 **`float f = 1.2f; int a = (int)f;`**

### 5. 带有参数的函数

1. C99规定：对实际参数或者实际参量使用术语 ***参数*** ； 对形式参数或者形式参量使用术语 ***参量***

2. 函数原型：是一个函数声明，描述了函数的返回值和参数

3. 每个运算符的特性包括：所需操作数的数量、优先级和结合性
 
## 第6章 C控制语句：循环

### 1. while语句

1. 每次循环都被称为一次迭代

2. 若while语句块为空语句，应该将分号放在下面的一行而不是放在同一行中，如下：	
	```
	while (scanf("%d", &num) == 1)
		;
	```
    
### 2. 比较大小：使用关系运算符和表达式

1. 在浮点数比较中只能使用**>**和**<**

2. 如果进行比较的双方中有一个是常量，则可以把它放在比较表达式的左边

3. 一个**_Bool**变量只可以具有值1(真)或0(假)，如果把一个非零的值赋给**_Bool**变量，则**_Bool**变量被设置为1

4. C99还提供了一个stdbool.h头文件，可以使用bool来代替_Bool，并把true和false定义为值1和0的符号常量，通过这种方式可以和C++兼容

### 3. 退出条件循环：do while

1. while循环和for循环是入口条件循环，do while循环是退出条件循环

2. do while循环本身就是一个语句，因此需要一个结束的分号

3. C99允许使用常量值制定数组大小，而C90不允许，但#define在两种情况下都可以使用

4. 现代编程习惯把程序的元素分为接口和实现两部分

## 第7章 C控制语句：分支和跳转

### 1. if语句

1. 在需要类型转换的地方，建议使用显式类型转换

2. C99标准要求编译器至少支持127层嵌套

### 2. 求值的顺序

1. 除了两个运算符共享一个操作数的情况以外，C通常不保证复杂表达式的哪个部分首先被求值

2. 判断一个字符是否是字符时，建议使用移植性更好的方法：使用ctype.h中声明的函数

### 3. 多重选择：switch和break

1. **switch**判断表达式应该具有整数值(包括char类型)；case标签必须是整型(包括char)常量或者整数常量表达式(仅包含整数常量的表达式)

## 第8章 字符输入/输出和输入确认

### 1. 单字符I/O：getchar()和putchar()

1. 输入回显：获取从键盘输入的字符并将其发送至屏幕

### 2. 缓冲区

1. 缓冲分为两类：完全缓冲I/O和行缓冲I/O；对于完全缓冲输入来说，缓冲区满时被清空，通常出现在文件输入中，缓冲区的大小取决于系统；对行缓冲I/O来说，遇到一个换行符时将被清空缓冲区，键盘输入是标准的行缓冲

2. 文件结束符：**Ctrl+D**

### 3. 重定向和文件

1. 使用重定向运算符(>、>>、<等)时，输入不能来自一个以上的文件，输出也不能定向至一个以上的文件

## 第9章 函数

### 1. 函数概述

1. 函数：用于完成特定任务的程序代码的自包含单元

2. **return;** 只能用于void类型的函数中

### 2. ANSI C的函数原型

1. 函数原型用来声明函数的返回值类型，参数个数以及各参数的类型；函数原型中可以省略参数变量名，函数原型中的参数变量名只是虚设的名字，不必和函数定义中使用的参数变量名想匹配；

2. 若使用函数原型 **void print_name();** ，ANSI C编译器不会进行参数检查；为了表示一个函数确实不适用参数，应当在圆括号内使用**void**关键字，如：**void print_name(void);**，这时当对该函数进行调用时，ANSI C编译器会检查函数参数以保证确实没有使用参数

### 3. 多源代码文件程序的编译

1. 编译第一个文件并将其链接到第二个文件的目标代码中：**gcc file1.c file2.o**

2. 在UNIX和DOS环境下，**#include "hotel.h"** 中的双引号表示被包含的文件位于当前工作目录下

### 4. 指针简介

1. 指针变量**ptr**和**&pooh**的区别：**ptr**为变量，而**&pooh**为常量

2. **\***和指针名之间的空格是可选的，通常在声明中使用空格，而在指向变量时省略空格

3. 函数的参数用于函数间通信，输入参数可以把调用函数中的数值传递给被调用函数，输出参数可以把被调用函数中的数值传递给调用函数
 
## 第10章 数组和指针

### 1. 数组

1. 如果不初始化数组，其中存储的时无用的数值；但是如果部分初始化数组，则未初始化的元素则被设置为0；变长数组除外

2. 指定初始化项目：C99规定，在初始化列表中使用带有方括号的元素下标可以指定某个特定的元素
	
	**a.** 如果一个指定初始化项目后跟有不止一个值，则这些数值将用来对后续的数组元素初始化	
	**b.** 如果多次对一个元素进行初始化，则会自动覆盖前面的数值，只有最后的一次生效

3. C不支持把数组作为一个整体来进行赋值，也不支持用花括号括起来的列表形式进行赋值(初始化赋值除外)

4. 变长数组：VLA，变长数组中得“变”指使用已初始化的变量值来指定数组大小，（**sizeof**表达式是一个整数常量，而一个**const**值不是整数常量）C99引入变长数组主要为了更适合于做数值计算

5. 多维数组初始化时，可以省略内部的花括号，只保留最外面的一对花括号，只要保证数值的个数正确即可

### 2. 函数、数组和指针

1. 在C中，对一个指针加1的结果是对该指针增加一个存储单元；对于数组而言，地址会增加到下一个元素的地址，而不是下一个字节

2. 在函数原型或函数定义头的场合(并且只有在这两种场合),可以用**int *arr**代替**int arr[]**

3. 向函数传递数组信息时的方法：
	
	**a.** 使用一个指针参量确定数组的开始地址；使用另一个整数参量来指明数组的元素个数	
	**b.** 传递两个指针，一个指针指明数组的起始地址，第二个指针指明数组的结束地址；如:**`while (start < end)`**,处理的最后一个元素将是end所指向的位置之前的元素，左闭右开区间，end实际指向的位置在数组最后一个元素之后；C保证在为数组分配存储空间的时候，指向数组之后的第一个位置的指针也是合法的

4. 指针符号(尤其在对其使用增量运算符时)更接近于机器语言，而且某些编译器在编译时能生成更高效的代码

### 3. 指针操作

1. 指针求差值：差值的单位是相应类型的大小，有效指针差值运算的前提是参加运算的两个指针是指向同一个数组(或是其中之一指向数组后面的第一个地址)

2. 不能对未初始化的指针取值

### 4. 保护数组内容

1. 如果函数想修改数组，那么在声明数组参量时就不要使用**const**;如果函数不需要修改数组，那么在声明数组参量时最好使用**const**

2. 将常量或非常量数据的地址赋给指向常量的指针(**const ***)是合法的；但只有非常量数据的地址可以赋给普通的指针

3. 在函数参量定义中使用**const**，不仅可以保护数据，而且使函数可以使用声明为**const**的数组

### 5. 指针和多维数组

1. 数组指针和指针数组：

    **a.** **数组指针**：指向一个数组的指针，本身是一个指针，指向一个数组；如：**`int (* p) [2];`**
    **b.** **指针数组**：本身是一个数组，数组元素为某种类型的指针；如：**`int * p[2];`**

2. 把**const**指针赋给非**const**指针是错误的，因为有可能使用新指针来改变**const**数据出现异常；但是把非**const**指针赋给**const**指针是允许的(**前提是只进行一层间接运算**)，如下：
    ```
    const int **p2;
    int *p1;
    const int n = 13;
    pp2 = &p1; //不允许，先假设允许
    *pp2 = &n; //合法，二者都是const，但同时会使p1指向n
    *p1 = 10; //合法，但这将改变const n的值
    ```
    
3. 编译器会把数组符号转换成指针符号

4. 通常声明N维数组的指针时，除了最左边的方括号可以留空之外，其他都需要填写数值；如：**`int sum(int arr[][12][20][30], int rows);`**;因为第一个方括号表示一个指针，而其他方括号描述的是所指向对象的数据类型

### 6. 变长数组(VLA)

1. 数组的行可以在函数调用时传递，但是数组的列却只能被预置在函数内部，这是因为数组的维数必须是常量

2. C99标准引入了变长数组，允许使用变量定义数组各维；但是变长数组必须是自动存储类的，因此必须在函数内部或作为函数参量声明，而且声明时不可以进行初始化；如：**`int sum(const unsigned int size, arr[size] = {0});`**是非法的

3. 声明带有一个二维变长数组参数的函数：**`int sum(int rows, int cols, int arr[rows][cols]);`**

4. C99标准规定可以省略函数原型中得名称；但是如果省略名称，则需要用星号来代替省略的维数；如：**`int sum(int, int, int arr[*][*]);`**

5. 变长数组允许动态分配存储单元，可以在程序运行时指定数组的大小

### 7. 复合文字

1. C99新增了复合文字，文字是非符号常量；对于数组来说，复合文字看起来像在数组的初始化列表前面加上用圆括号括起来的类型名；如：**`(int [2]) {10, 20}`**是一个复合文字

2. 像初始化一个命名数组时可以省略数组大小一样，初始化一个复合文字也可以省略数组大小，编译器会自动计算元素的数目；如：**`(int []) {50, 20, 90}`**是一个有三个元素的复合文字

3. 对于未命名的复合文字，必须在创建它们的同时通过某种方法来使用它们；通常有两种方法：

    **a.** 一种方法是使用指针保存其位置，如：**`int * pt1; pt1 = (int [2]){10, 20};`**;    
    **b.** 另一种方法是作为实参被传递给带有类型与之匹配的形参的函数，如：
    ```
    int sum(int arr[], int n);
    ......
    int total3;
    total3 = sum((int []){4, 4, 4, 5, 5, 5}, 6);
    ```

## 第11章 字符串和字符串函数

### 1. 字符串表示和字符串I/O

1. 如果字符串文字中间没有间隔或者间隔是空格符，ANSI C会将其串联起来；如：**`char str[50] = "Hello, and" "how are" "you" "today!";`**等同于**`char str[50] = "Hello, and  how are you today!";`**

2. 字符串常量属于静态存储，在程序运行过程中只存储一份

3. 指定字符串数组大小时，一定要确保数组元素数比字符串长度至少多1，未被使用的元素将被自动初始化为0

4. 增量运算符只能用在变量名前，不能用在常量前

5. 数组初始化是从静态存储区把一个字符串复制给数组，而指针初始化只是复制字符串的地址

6. 数组的元素是变量，但是数组名不是变量，不能对数组名进行自增自减运算

7. 初始化一个指向字符串文字的指针时应使用**const**修饰符，因为编译器可能选择内存中的同一个单个的拷贝，来表示所有相同的字符串文字，如果不加**const**，可能会修改某个单元，这样会影响到所有对这个字符串的使用；用一个字符串文字来初始化一个非**const**的数组，则不会出现这种那个情况，因为数组从最初的字符串得到了一份拷贝

### 2. 字符串输入

1. **gets()**读取换行符之前（不包括换行符）的所有字符，并在其后添加一个空字符**\0**，**gets()**会读取换行符并将其丢弃；如果出错或遇到文件结尾**(EOF)**，将返回一个空地址**(NULL)** 

2. **fgets()**如果第二个参数指定最大读入字符数为n，会读取最多**n-1**个字符或读完一个换行符为止；**fgets()**读到换行符后会将其存入字符串而不像**gets()**一样丢弃;由于**gets()**不检查目标数组是否能够容纳输入，存在不安全因素

### 3. 字符串输出

1. **puts()**显示字符串时自动在其后添加一个换行符；**puts()**遇到空字符时会停止输出

2. **fputs()**不会为输出自动添加换行符；

3. **gets()**丢掉输入里的换行符，但是**puts()**为输出添加换行符；**fgets()**存储输入的换行符，而**fputs()**不为输出添加换行符

### 4. 自定义字符串输入/输出函数

1. 用方括号的一个用意是提醒用户这个函数处理的时数组而不是字符串；如：**`const char *string`**和**`const char string[]`**

### 5. 字符串函数

1. **strcat()**函数并不检查第一个数组是否能够容纳第二个字符串；如果没有为第一个数组分配足够大得空间，多出来的字符溢出到相邻存储单元时就会出现异常；

2. **`char * strncpy(char * s1, const char * s2, size_t n)`**：如果源字符串的字符数少于n个，在目标字符串中以空字符填充；***如果源字符串的字符数大于或等于n个，空字符将不会被复制到目标字符串，需要在目标字符串最后手动添加空字符(\0)***

3. **strlen()**函数测得的字符串长度不包含空字符

## 第12章 存储类、链接和内存管理

### 1. 存储类

1. 作用域：一个C变量的作用域可以是**代码块作用域**、**函数原型作用域**，或者**文件作用域**

    **a.** **代码块作用域**：在代码块中定义的变量具有代码块作用域，从该变量被定义的地方到包含该定义的代码块的末尾该变量均可见；传统上，具有代码块作用域的变量都必须在代码块的开始处进行声明，但是C99放宽了这一规则，允许在一个代码块中任何位置声明变量    
    **b.** **函数原型作用域**：函数原型作用域从变量定义处一直到原型声明的末尾    
    **c.** **文件作用域**：一个在所有函数之外定义的变量具有文件作用域

2. 链接：一个C变量可能具有**外部链接**、**内部链接**，或**空链接**；具有代码块作用域或者函数原型作用域的变量具有空链接，一个具有外部链接的变量可以在多文件程序的任何地方使用，一个具有内部链接的变量可以在一个文件的任何地方使用；如：    
    ```
    int giants = 5;    //文件作用域，外部链接
    static int dodgers = 3;    //文件作用域，内部链接
    
    int main(void)
    {
        int size = 10;    //代码块作用域，空链接
    }
    ...
    ```

3. **存储时期**：一个C变量可以有以下两种存储时期之一

    **a.** **静态存储时期**：如果一个变量具有静态存储时期，它在程序执行期间将一直存在；具有文件作用域的变量具有静态存储时期    
    **b.** **自动存储时期**：具有代码块作用域的变量一般情况下具有自动存储时期

4. 存储类：C使用作用域、链接和存储时期来定义5中存储类：自动、寄存器、具有代码块作用域的静态、具有外部链接的静态，以及具有内部链接的静态

    **a.** **自动变量**：属于自动存储类的变量具有自动存储时期、代码块作用域和空链接；默认情况下，在代码块或函数的头部定义的任意变量都属于自动存储类；也可以显式地使用关键字**auto**(存储类说明符)；除非显式地初始化自动变量，否则它不会被自动初始化    
    **b.** **寄存器变量**：具有代码块作用域、空链接以及自动存储时期；可以用存储类说明符**register**声明寄存器变量；声明一个变量为寄存器类变量仅是一个请求，编译器必须在用户请求与可用寄存器的个数或可用高速内存的数量之间做权衡，如果资源无法满足，很可能将寄存器变量当作一个普通的自动变量处理；可以使用**register**变量声明的类型是有限的    
    **c.** **具有代码块作用域的静态变量**：“静态”指变量的位置固定不动；具有静态存储时期、代码块作用域和空链接；静态变量只在编译时被初始化一次，如果不显式地对静态变量进行初始化，默认将被初始化为0；处于代码块中得静态变量声明定义语句，实际上并不是代码块的一部分，将该语句放置在代码块中只是为了告诉编译器只有该代码块可以看到该变量，该语句不是在运行时执行的语句，而是在编译阶段已经执行，分配空间并初始化；对函数参量不能使用**static**；如：**`int wontwork(static int flu);`**    
    **d.** **具有外部链接的静态变量**：具有文件作用域、外部链接和静态存储时期；可以在使用外部变量的函数中通过使用**extern**关键字来再次声明；如果变量是在别的文件中定义的，使用**extern**来声明该变量就是必须得；只可以用常量表达式来初始化文件作用域变量；不要用关键字**extern**来进行外部定义；只用它来引用一个已经存在的外部定义；一个外部变量只可进行一次初始化，而且一定是在变量被定义时进行    
    **e.** **具有内部链接的静态变量**：具有静态存储时期、文件作用域以及内部链接；普通的外部变量可以被程序的任一文件中所包含的函数使用，而具有内部链接的静态变量只可以被与它在同一个文件中得函数使用；可以在函数中使用存储类说明符**extern**来再次声明任何具有文件作用域的变量，这样的声明不改变链接

### 2. 存储类说明符

1. C语言中有5个作为存储类说明符的关键字：**auto**、**register**、**static**、**extern**以及**typedef**

2. 不可以在一个声明中使用一个以上的存储类说明符

3. **auto**和**register**只能用在具有代码块作用域的变量声明中

4. 无法获取一个寄存器变量的地址

### 3. 存储类和函数

1. 外部函数可被其他文件中的函数调用，静态函数只可以在定义它的文件中使用

2. **rand()**是一个“伪随机数发生器”

### 4. 分配内存：**malloc()**和**free()**

1. ANSI C标准使用了一个新类型：指向**void**的指针，被称为“通用指针”；将**void**指针值赋给其他类型的指针并不构成类型冲突；如果**malloc()**找不到所需的空间，它将返回空指针

2. 在C中，类型指派是可选的，而在C++中必须有，通常选择都使用类型指派；如：**`ptd = (double *)malloc(max * sizeof(double));`**

3. **calloc()**：如，**`long * newmem = (long *)calloc(100, sizeof(long));`**第一个参数是所需内存单元的数量，第二个参数是每个单元以字节计的大小；函数**calloc()**会将块中全部位都置为0

### 5. ANSI C 的类型限定词

1. C99授予类型限定词一个新属性：幂等性；即可以在一个声明中不止一次地使用同一限定词，多余的将被忽略；如：**`const const const int n = 6;//相当于: const int n = 6;`**

2. 常量指针(**const * **)：一个位于** * **左边任意位置的**const**使得数据成为常量；指针常量(** * const**)：一个位于** * **右边的**const**使得指针自身为常量

3. 在文件之间共享**const**数据时要小心，可以使用两个策略：

    **a.** 遵循外部变量的惯用规则，在一个文件中进行定义声明，在其他文件中使用关键字**extern**进行引用声明；
    ```
    /* file1.c --定义一些全局常量 */
    const double PI = 3.14159;
    const char * MONTHS[12] = 
        {"Jannuary", "February", "March", "April", "May", "June"
        "July", "August", "September", "October", "November", "December"};
                
    /* file2.c --使用在其他文件中定义的全局常量 */
    extern const double PI;
    extern const char * MONTHS[];
    ```    
    **b.** 将常量放在一个**include**文件中，同时使用静态外部存储类；
    ```
    /* constant.h --定义一些全局变量 */
    static const double PI = 3.14159;
    static const char * MONTHS[12] = 
        {"Jannuary", "February", "March", "April", "May", "June"
        "July", "August", "September", "October", "November", "December"};
    
    /* file1.c --使用在其他文件中定义的全局变量 */
    #include  "constant.h"
    
    /* file2.c -- 使用在其他文件中定义的全局变量 */
    #include  "cosntant.h"
    ```    
    如果不使用关键字**static**，在文件file1.c和file2.c中包含constant.h将导致每个文件都有同一标识符的定义声明，ANSI标准不支持这样做；通过使每个标识符成为静态外部的，实际上给了每个文件一个独立的数据拷贝，每个文件都只能看到它自己的拷贝，无法使用该数据来与另一个文件通信；使用头文件的好处是不必考虑在一个文件中进行定义声明，在下一个文件中进行引用声明，只需包含相关头文件即可，全部文件都包含同一个头文件，缺点在于复制了数据，当头文件包含较大的常量数据时可能存在问题

4. 限定词**volatile**告诉编译器该变量除了可被程序改变以外还可被其他代理改变

5. 关键字**restrict**通过允许编译器优化某几种代码增强了计算支持；只可用于指针，并表明指针是访问一个数据对象的惟一且初始的方式

6. 函数**memcpy()**要求两个位置之间不重叠，但**memmove()**没有这个要求；如：**`void * memcpy(void * restrict s1, const void * restrict s2, size_t n);`**

### 6. 总结

1. 用于存储程序数据的内存可用存储时期、作用域和链接来表征。
    
    **a.** 存储时期可以是静态的、自动的或者分配的；如果是静态的，内存在程序开始执行时被分配，并在程序运行时一直存在；如果是自动的，变量所用内存在程序执行到该变量定义所在代码块时开始分配，在退出代码块时释放；如果是分配的内存，内存通过**malloc()**(或其他相关函数)分配，通过调用**free()**释放
    **b.** 作用域决定了哪一部分程序可以访问某个数据。在所有函数之外定义的变量具有文件作用域，并对该变量声明之后定义的全部函数可见；在代码块内定义或者作为函数参量定义的变量具有代码块作用域，并只在该代码块及其子代码块中可见
    **c.** 链接描述了程序的某个单元定义的变量可被链接到其他哪些地方。具有代码块作用域的变量作为局部变量，具有空链接；具有文件作用域的变量可有内部链接或外部链接；内部链接意味着变量只可在包含变量定义的文件内部使用；外部链接意味着变量也可在其他文件中使用

2. 类型限定词说明符有**const**、**volatile**和**restrict**。

## 第13章 文件输入/输出

### 1. 和文件进行通信

1. 程序和文件通信的一种方式就是**文件重定向**。

2. 一个文件通常就是磁盘上的一段命名的存储区。

3. **C**将文件看成是连续的字节序列，其中每一个字节都可以单独地读取。

4. 两种文件视图：**文本视图**和**二进制视图**。在二进制视图中，文件中的每个字节都可以为程序所访问。在文本视图中，程序看到的内容和文件的内容有可能不同。

5. **C**程序使用一个 **\n** 表示行尾。

6. 通常对于文本文件使用文本视图，对于二进制文件使用二进制视图。

7. 低级**I/O**使用操作系统提供的基本**I/O**服务；标准高级**I/O**使用一个标准的**C**库函数包和**stdio.h**头文件中的定义。**ANSI C**只支持标准**I/O**包。

8. 3个标准文件：**标准输入**、**标准输出**、**标准错误输出**

### 2. 标准 **I/O**

1. 除了可移植性以外，标准I/O包相对于低级I/O有两点优势：

	**a.** 标准I/O包中包含很多专用的函数，可以方便地处理不同的I/O问题。
	**b.** 对输入和输出进行了缓冲。

2. 为了获得最大的可移植性，应该使用宏**EXIT_SUCCESS**和**EXIT_FAILURE**。

3. 如果**main()**在一个递归程序中，**exit()**仍然会终止程序；但**return**将控制权移交给递归的前一级，直到最初的一级**return**才会终止程序。即使在除**main()**之外的函数中调用**exit()**，也将终止程序。

4. **“w”**/**"w+"**如果文件存在会先将文件长度截为0，如果不存在则先创建文件。**如果使用任何一种"w"模式打开一个已有的文件，文件内容将被删除！**

5. **b**使用二进制模式打开文件，对于**Unix**和**Linux**这样只有一种文件类型的系统，带**b**字母的模式和对应的不带**b**的模式是相同的，为了兼容性，建议带**b**。

6. 文件指针是一种指向**FILE**的指针；**FILE**是**stdio.h**中定义的一种派生类型。指针**fp**并不指向实际的文件，而是指向一个关于文件的信息的数据包，其中包括文件**I/O**使用的缓冲信息。

7. **getchar()**使用作为标准输入的**getc()**定义。

8. 为了避免试图读取空文件带来的问题，应对文件输入使用入口循环（而不是**do while**循环）。

9. 如果文件成功关闭，**fclose()**函数将返回值0，否则返回**EOF**。

10. 在**DOS**环境下不能再为文件后缀添加后缀（适用于**MS-DOS**的方法是使用当前后缀替换任何已有的后缀）。

### 3. 文件 **I/O**：**fprintf()**、**fscanf()**、**fgets()**、**fputs()**

1. **fgets()**函数向末尾添加一个空字符构成一个字符串。**fgets()**遇到**EOF**时返回**NULL**值。

2. **fgets()**函数保留了换行符，**fputs()**函数打印时并不添加一个换行符。

3. **fgets()**函数可以防止存储溢出。

### 4. 随机存取：**fseek()**和**ftell()**

1. **ftell()**函数以一个long类型值返回一个文件的当前位置。
	- 正：前移
	- 负：后移
	- 零：保持不动

2. 文件的起始点模式：
	- **SEEK_SET**：文件开始
	- **SEEK_CUR**：当前位置
	- **SEEK_END**：文件结尾
	
3. 如果一切正常，**fseek()**的返回值为0。如果有错误，如试图移动超出文件范围，则**fseek()**返回值-1。

4. **ftell()**函数通过返回距文件开始处的字节数目来确定文件的位置。文件的第一个字节到文件开始处的距离是字节0。

### 5. 标准**I/O**内幕

1. **fopen()**函数不仅打开一个文件，而且建立了一个缓冲区（在读写模式下将建立两个缓冲区），还创建了一个包含文件和缓冲区相关数据的数据结构，还返回一个指向该结构的指针。

2. 这个数据结构通常包括一个**文件位置指示器**（以确定在流中的当前位置）。还包括**错误指示器**和**文件结尾指示器**、一个**指向缓冲区起始处的指针**、一个**文件标识符**，和一个记录实际复制到缓冲区中的字节数的**计数器**。

3. 缓冲区的大小依赖于具体的实现，但通常是512字节或者它的倍数。除了填充缓冲区外，初次函数调用还将设置**fp**所指的结构中的值。将设置流的当期位置和复制到缓冲区中的字节数。通常当前位置从字节0开始。

4. 数据结构和缓冲区初始化后，输入函数将从缓冲区中读取所请求的数据。同时，文件位置指示器被置为紧随最后一个被读取字符的位置。

5. 当输入函数检测到已经读取了缓冲区中的全部字符时，它会请求系统将下一块缓冲区大小的数据复制到缓冲区。函数在读入最后一缓冲区数据中的最后一个字符后，会将文件结尾指示器的值设置为真，下一个被调用的输入函数将返回**EOF**。

6. 输出函数将数据写入缓冲区。当缓冲区已满时，就将数据复制到文件中。

### 6. 其他标准**I/O**函数

1. **`int ungetc(int c, FILE *fp)`**函数**c**指定的字符放回输入流中。如果向输入流中放入了一个字符，下一次调用标准输入函数就会读入这个字符。**ANSI C**标准保证每次只会放回一个字符，如果一个**C**实现允许将一行里的多个字符放回输入流，那么输入函数就会以与放回时相反的顺序来读入。

2. **`int fflush(FILE *fp)`**函数可以将缓冲区中任何未写的数据发送到一个由**fp**指定的输出文件去，称为**刷新缓冲区**。如果**fp**是一个空指针，将刷新掉所有的输出缓冲。对于一个输入流使用**fflush()**函数的效果没有定义。（Windows下对输入流同样有效，但Linux下对输入流无效，可用**stdio_ext.h**头文件下的**__fpurge()**代替）。

3. **`int setvbuf(FILE * restrict fp, char * restrict buf, int mode, size_t size)`**函数。打开文件以后，在没有对流进行任何操作以前，可以调用这个函数。
	- 如果**buf**的值不是**NULL**，就必须创建这个缓冲区。如果**buf**的值为**NULL**，函数会自动为自己分配一个缓冲区。
	- **mode**可选取：**_IOFBF**表示完全缓冲（缓冲区满的时候刷新）、**_IOLBF**表示行缓冲（缓冲区满的时候或者一个新行写入的时候刷新）、**_IONBF**表示无缓冲。

7. 一些标准**I/O**函数是面向文本的，用于处理字符和字符串。如果使用**fprintf()**和**%f**格式保存一个浮点值，会将它作为字符串存储。如使用**%.2f**说明符可以把0.333333存储为4字符的字符串0.33，但是读取文件的时候就没有办法恢复其完整的精度。**fprintf()**函数以一种可能改变数字值的方式将其转换成为字符串。如果把数据存储在一个使用与程序具有相同表示方法的文件中，就称数据以二进制形式存储，这中间没有从数字形式到字符串形式的转换。对于标准**I/O**，**fread()**和**fwrite()**函数提供了这种二进制服务。

8. **int feof(FILE * fp)**和**int ferror(FILE * fp)**函数：当标准输入函数返回**EOF**时，通常表示已经到达了文件结尾。但是这也有可能表示发生了读取错误。使用**feof()**和**ferror()**函数可以区分这两种可能性。
	- 如果最近一次输入调用检测到文件结尾，**feof()**函数返回一个非零值，否则返回零值。
	- 如果发生读写错误，**ferror()**函数返回一个非零值，否则返回零值。

9. 使用二进制**I/O**进行随机存取：随机存取最常用于使用二进制**I/O**写入的二进制文件。

10. 如果需要在不损失精度的前提下保存或者恢复数字处理，请使用二进制模式，并利用**fread()**和**fwrite()**函数。如果是保存文本信息或者是要创建可以用普通文本编辑器查看的文件，请使用文本模式和诸如**getc()**、**fprintf()**之类的函数。

11. **ANSI C**提供两种打开文件的模式：**二进制模式**和**文本模式**。以二进制模式打开一个文件时，可以逐字节地读取。以文本模式打开一个文件时，会把文件内容从具体系统的文本表示法映射到**C**表示法。

12. **fseek()**和**ftell()**函数允许程序移动到文件中任意位置进行随机存取。

## 第14章 结构和其他数据形式

### 1. 结构声明

1. 结构体声明可以放在任何函数外面，也可以放在一个函数定义内部。如果将结构体声明置于一个函数内部，它的标记只能在该函数内部使用。

### 2. 定义结构变量

1. 结构声明实际上创建了一种**struct**的新类型。如：
	```
	struct book {
		char title[MAXTITL];
		char author[MAXAUTL];
		float value;
	};
	struct book library;
	```
	可简化为：
	```
	struct book {
		char title[MAXTITL];
		char author[MAXAUTL];
		float value;
	} library;	
	```
	将声明和变量定义合并在一起，是不需要使用标记的一种情况。
	```
	struct {
		char title[MAXTITL];
		char author[MAXAUTL];
		float value;
	} library;
	```
	如果想多次使用一个结构类型，就需要使用带有标记的形式。

2. 使用一个用花括号括起来的、逗号分隔的初始化项目列表进行初始化。

3. 如果初始化一个具有静态存储时期的结构，初始化项目列表中的值必须是常量表达式。

4. **“.”**优先级高于**“&”**，表达式**`&library.float`**等同于**`&(library.float)`**。

5. **C99**支持结构的指定初始化项目，使用点运算符和成员名（而不是方括号和索引值）来标识具体的元素。可按照任意的顺序使用指定初始化项目。
 
### 3. 结构数组

```
while (getchar() != '\n')
{//清空输入行
	continue;
}
```

### 4. 向函数传递结构信息

1. C允许把一个结构A赋值给另一个结构B，`B = A;`会使B的每个成员都被赋成A相应成员的值，即使有个成员是一个数组也照样完成赋值。

2. 应该用结构指针作为函数参数，还是用结构作为函数参数和返回值呢？
	- 把结构指针作为参数：执行速度快，只须传递一个单个地址；缺点是缺少对数据的保护，被调函数中的一些操作可能影响到原来结构中的数据（可以通过**const**限定词来解决这个问题）。
	- 把结构作为参数：函数处理的是原始数据的副本。但是如果把很大的结构传递给函数，函数只使用了一个或两个结构成员，浪费时间和空间（此时，传递结构指针更为合理）。

	注：通常为了提高效率而使用结构指针作为函数参数，当需要保护数据、防止意外改变数据时对结构指针使用**const**限定词。传递结构值是处理小型结构最常用的方法。

3. 在结构中使用字符数组还是字符指针？
	```
	#define LEN 20
	struct names
	{
		char first[LEN];
		char last[LEN];
	};
	struct pnames
	{
		char * first;
		char * last;
	};
	//对于如下代码均可正常运行
	struct names veep = {"Talia", "Summers"};
	struct pnames treas = {"Brad", "Fallingjaw"};
	printf("%s and %s\n", veep.first, treas.first);
	//但是对于如下代码则不能正常运行，会出现指针未初始化错误
	struct names accountant;
	struct pnames attorney;
	puts("Enter the last name of your accountant:");
	scanf("%s", accountant.last);
	puts("Enter the last name of your attorney:");
	scanf("%s", attorney.last);//attorney.last指针未初始化	
	```
如果需要一个结构来存储字符串，应使用字符数组成员，或者使用**malloc()**动态分配内存。

4. 复合文字和结构
	- 使用复合文字给结构变量赋值：
	```
	struct book readfirst = 
		(struct book){
			"Crime and Punishment",
			"Fyodor Dostoyevsky",
			9.99 };
	```
	- 把复合文字作为函数参数：
	```
	struct rect
	{
		double x;
		double y;
	};
	double rect_area(struct rect r)
	{
		return r.x * r.y;
	}
	double area;
	area = rect_area((struct rect){10.5, 20.0});
	```
	- 把复合文字的地址传递给函数：
	```
	double rect_areap(struct rect * rp)
	{
		return rp->x * rp->y;
	}
	double area;
	area = rect_areap(&(struct rect){10.5, 20.0});
	```
	- 也可以在复合文字中使用指定初始化项目

5. 伸缩型数组成员（**C99**）
	- 利用这一特性可以声明最后一个成员是一个具有特殊属性的数组的结构：
(1)该数组成员不存在，至少不立即存在；
(2)可以编写适当的代码使用这个伸缩型数组成员，就像它确实存在并且拥有需要的任何数目的元素一样；
	- 声明一个伸缩型数组成员的规则：
		- 伸缩型数组成员必须是最后一个数组成员；
		- 结构中必须至少有一个其他成员；
		- 伸缩型数组就像普通数组一样被声明，除了它的方括号内是空的；
	```
	struct flex
	{
		int count;
		double average;
		double scores[];
	};
	```
	- **C99**的意图并不是声明一个**struct flex**类型的变量，而是声明一个指向**struct flex**类型的指针，然后使用**malloc()**分配足够的空间，以存放**struct flex**结构的常规内容和伸缩型数组成员需要的任何额外空间。例如，假设想用**scores**表示含有5个**double**型数值的数组，可以使用如下方法：
	```
	struct flex * pf;
	pf = malloc(sizeof(struct flex) + 5 * sizeof(double));
	……
	struct flex * pf1, pf2;
	int n = 5;
	pf1 = malloc(sizeof(struct flex) + n * sizeof(double));
	n = 9;
	pf2 = malloc(sizeof(struct flex) + n * sizeof(double));
	```
6. 把结构内容保存到文件：
最没效率的保存方法是使用**fprintf()**，一个更好的解决方法是使用**fread()**和**fwrite()**函数以结构体的大小为单元进行读写。如：
	```
	fwrite(&primer, sizeof(struct book), 1, pbooks);
	```

### 5. 联合（**union**）

1. 联合是一种能在同一个存储空间里（但不同时）存储不同类型数据的数据类型。如：
	```
	union hold
	{
		int digit;
		double bigfl;
		char letter;
	};
	//这个联合体可以含有一个int型数值或一个double型数值或一个char型数值；	
	```
	
2. 即使有足够的空间，联合体也只存储一个值，初始化规则有3种：
	- 把一个联合体初始化为同样类型的另一个联合体；
	- 初始化联合体的第一个元素；
	- 使用一个指定初始化项目；

	```
	union hold valA;
	valA.letter = 'R';
	union hold valB = valA;
	union hold valC = {88};
	union hold valD = {.bigfl = 118.2};
	//点运算符表示正在使用哪种数据类型
	```
	
### 6. 枚举（**enum**） 

1. 可以使用枚举类型声明代表整数常量的符号名称。目的是提高程序可读性。
	```
	enum day = {Sun, Mon, Tue, Wed, Thu, Fri, Sat};
	```
	
	注：C的某些枚举属性不能延至C++中，例如，C允许对枚举变量使用运算符++，而C++不允许。

2. 在使用整数常量的任何地方都能使用枚举常量。枚举列表中的常量默认被指定为整数值0、1、2等，也可以指定枚举常量具有的整数值。枚举类型是一个整数类型。

3. 共享的命名空间
	- 普通变量的命名空间相同但是具有不同作用域的两个变量不会冲突，而命名空间相同并在相同作用域中的两个变量会冲突。命名空间是分类别的。
	- 对于**C**，在一个特定作用域内的结构标记、联合标记以及枚举标记都共享同一个命名空间，但是与普通变量不同，可以在同一个作用域内对一个变量和一个标记使用同一个名字，但是不会产生错误；但是不能在同一作用域内使用名字相同的两个标记或名字相同的两个变量。
	注：C++不允许在同一个作用域内对一个变量和一个标记使用同一个名字，应避免这种写法。

### 7. **typedef**

1. 与**#define**的三个不同点：
	- **typedef**给出的符号名称仅限于对类型，而不是对值；
	- **typedef**由编译器解释，而不是预处理器；
	- 在一定范围内，**typedef**比**#define**更灵活。

2. 使用**typedef**来命名一个结构类型时，可以省去结构的名字：
	```
	typedef struct 
	{
		double x;
		double y;
	} rect;
	rect r1 = {3.0, 6.0};
	rect r2;
	r2 = r1;
	//这被翻译成：
	struct {double x; double y} r1 = {3.0, 6.0};
	struct {double x; double y} r2;
	r2 = r1;
	```
	注：如果两个结构的声明都不使用标记，但是使用同样的成员（成员名和类型都匹配），C认为这两个结构具有同样的类型，可以互相赋值。

3.  修饰符的顺序
	- **[]**和**()**具有相同的优先级，且优先级高于*****的优先级；
	- **[]**和**()**从左至右结合；
	
	```
	int * risks[10];//具有10个元素的数组，每个元素是一个指向int的指针
	int (* risks) [10];//一个指针，指向具有10个元素的int数组
	```

### 8. 函数和指针

1. 声明一个指向特定函数类型的指针时，首先声明一个该类型的函数，然后用**(*pf)**形式的表达式替换函数名称即可。

2. 函数指针最常用作函数的参数。

3. 使用**typedef**：
	```
	typedef void (*V_FP_CHARP) (char *);
	void show (V_FP_CHARP fp, char *);
	V_FP_CAHRP pfun;
	```
	还可以声明并初始化一个函数指针的数组：
	V_FP_CHARP arpf[4] = { ToUpper, ToLower, Transpose, Dummy};

## 第15章 位操作

### 1. C的位运算符

1. 位逻辑运算符	
	- 按位取反：**~**
	- 按位与：**&**
	```
	val &= 0377;
	//等价于
	val = val & 0377;
	```
	- 按位或：**|**
	- 按位异或：**^**

2. 掩码
掩码是某些位设为开**(1)**而某些位设置为关**(0)**的位组合。使用按位与操作。如：设置掩码**MASK**为2，即二进制**00000010**，**`flags = flags & MASK;`**

3. 打开位
使用按位或来实现。**`flags = flags | MASK;`**

4. 关闭位
**`flags = flags & ~MASK;`**

5. 转置位
转置一个位表示如果该位打开，则关闭该位；如果该位关闭，则打开该位。可以使用按位异或来实现转置一个位。如：**`flags = flag ^ MASK;`**对应掩码位为1的位被转置，对应掩码位为0的位不改变。

6. 查看一个位的值
如：**`if ((flag & MASK) == MASK)`**，位掩码至少应该与其所屏蔽的值具有相同的宽度。

7. 移位运算符
	- 左移运算符**<<**：空出的位用0填充，并且丢弃移出左侧操作数末端的位。
	注：该操作产生一个新位值，但是不改变其操作数。
	- 右移运算符**>>**：丢弃移出左侧操作数右端的位。对于**unsigned**类型，使用0填充左端空出的位；对于有符号类型，解雇依赖于及其，空出的位可能用0填充，或者使用符号位的副本填充。

8. 用法：移位运算符
移位运算符能够提供快捷、高效的对2的幂的乘法和除法。
	- **number << n**：number乘以2的n次幂；
	- **number >> n**：如果number非负，则用number除以2的n次幂；


### 2. 位字段

1. 位字段是一个signed int或unsigned int中一组相邻的位。位字段由一个结构声明建立，该结构声明为每个字段提供标签，并决定字段的宽度。带有位字段的结构允许在单个单元中存储多项设置。如：
	```
	struct 
	{
		unsigned int autfd: 1;
		unsigned int bldfc: 1;
		unsigned int undln: 1;
		unsigned int itals: １;
	} prnt;
	//使用：
	prnt.itals = 0;
	prnt.undln = 1;
	//对于某个设置有两个以上选择，可以用多位来表示所有的选择
	struct
	{
		unsigned int code1: 2;
		unsigned int code2: 2;
		unsigned int code3: 8;
	} prcode;
	//使用：
	prcode.code1 = 0;
	prcode.code2 = 3;
	prcode.code3 = 102;//只需确保值没有超出字段的容量	
	```

2. 如果声明的总位数超过一个unsigned int大小，将使用下一个unsigned int存储位置，不允许一个字段跨越两个unsigned int之间的边界。编译器会自动移位一个这样的字段定义，使字段按unsigned int边界对齐。发生这种情况时，会在第一个unsigned int中留下一个未命名的洞，可以使用未命名的字段宽度“填充”未命名的洞。如：
	```
	//使用一个宽度为0的未命名的字段迫使下一个字段与下一个整数对齐
	struct
	{
		unsigned int field1: 1;
		unsigned int       : 2;
		unsigned int field2: 1;
		unsigned int       : 0;
		unsigned int field3: 1;
	} stuff;
	```
注：C使用unsigned int作为位字段结构的基本布局单元。

## 第16章 C预处理器和C库

### 1. 翻译程序的第一步

1. 对程序做预处理前，编译器会对它进行几次翻译处理。
	- 编译器首先把源代码中出现的字符映射到源字符集；
	- 编译器查找反斜线后紧跟换行符的实例并删除这些实例，将多个物理行转换为一个逻辑行（“换行符”代表按下回车键在源代码文件中新起一行所产生的字符，而不是字符**\n**所代表的字符）；
	- 编译器将文本划分成预处理的语言符号序列和空白字符及注释序列，编译器用一个空格字符代替每一个注释。C实现可能还会选用单个空格代替每一个空白字符（不包括换行符）序列。
	- 最后，程序进入预处理阶段。预处理寻找可能存在的预处理指令（这些指令由一行开始处的**#**符号标识）。

### 2. 明显常量：#define

1. 预处理器指令从**#**开始，到其后第一个换行符为止，指令的长度仅限于一个逻辑行。可以通过反斜线**"\"**把指令扩展到多个物理行（第二行要左对齐）。

2. 每个#define行由三部分组成。
	- 指令#define自身；
	- 所选择的缩略语，即宏；
	- 替换列表（主体）；

3. 从宏变成最终的替换文本的过程称为宏展开。可以使用标准的C注释方法在#define行中进行注释，在预处理器处理之前，每个注释都会被一个空格所代替。

4. 预处理器不进行计算，只是按照指令进行文字替换操作，C编译器在编译时对所有常量表达式求值。

5. 一般而言，预处理器发现程序中的宏后，会用它的等价替换文本代替宏。如果该字符串中还包括宏，则继续替换这些宏。但是双引号中的宏不作替换。
	```
	#define OW "Hello World!"
	printf("TWO: OW");
	//将打印出TWO: OW，而不是打印出TWO: Hello World!
	```
	
6. 宏常量可以用来指定标准数组的大小并作为const值的初始化值。
	```
	#define LIMIT 20
	const int LIM = 50;
	static int data1[LIMIT];//合法
	static int data2[LIM];//无效
	const int LIM2 = 2 * LIMIT;//合法
	const int LIM3 = 2 * LIM;//无效
	```

7. 语言符号：
C预处理器中的语言符号是宏定义主体中的单独的词。用空白符把这些词分开。	
	
	```
	#define FOUR 2*2
	//有一个语言符号：即序列2*2
	#define FOUR 2 * 2
	//有三个语言符号：2、*和3
	```

8. 重定义常量：
ANSI标准只允许新定义与旧定义完全相同。相同定义意味着主体具有相同顺序的语言符号。
	
	```
	//下面两个定义相同
	#define SIX 2 * 3
	#define SIX 2  *  3
	//下面的定义与上面的不同
	#define SIX 2*3
	```
	注：如果确实需要重定义常量，使用const关键字和作用域规则可能会更容易。

### 3. 在#define中使用参数

1. 类函数宏：
	```
	//定义:SQUARE宏标识符，X宏的参数，X*X替换列表
	#define SQUARE(X) X*X
	//上述写法存在缺陷
	//调用
	z = SQUARE(2);
	```
	注：必须使用足够多的圆括号来保证以正确的顺序进行运算和结合
	```
	#define SQUARE(X) ((X) * (X))
	//如：
	int x = 4;
	SQUARE(x+2);
	100 / SQUARE(2);
	SQUARE(++x);//这种写法仍然存在缺陷和不确定性
	```
	注：避免在宏参数中使用增量或减量运算符。编译器对这些运算顺序没有做出规定。
	
2. 利用宏参数创建字符串：**#**运算符
	```
	#define PSQR(X) printf("The square of x is %d.\n", ((X) * (X)));
	//调用
	PSQR(8);
	//输出为：The square of x is 64.
	//引号中的字符串中的x被看作普通文本，而不是被看作一个可被替换的语言符号
	```
	注：在类函数宏的替换部分中，**#**符号用作一个预处理运算符，可以把语言符号转化为字符串，该过程称为字符串化。
	```
	#define PSQR(X) printf("The square of #x is %d.\n", ((X) * (X)));
	//调用
	PSQR(8);
	//输出为：The square of 8 is 64.
	```

3. 预处理器的粘合剂：**##**运算符
**##**运算符可以用于类函数宏的替换部分，也可以用于类对象宏的替换部分。作用：把两个语言符号组合成单个语言符号。
	
	```
	#define XNAME(n) x ## n
	//宏调用
	XNAME(4)
	//展开后：x4
	```	
	```
	#include <stdio.h>
	#define XNAME(n) x ## n
	#define PRINT_XN(n) printf("x" #n " = %d\n", x ## n);
	int main()
	{
		int XNAME(1) = 14;//变为 int x1 = 14;
		int XNAME(2) = 20;//变为 int x2 = 20;
		PRINT_XN(1);//变为 printf("x1 = %d\n", x1);
		PRINT_XN(2);//变为 printf("x2 = %d\n", x2);		
		return 0;
	}	
	```

4. 可变宏：**...**和**\__VA_ARGS__**
有些函数（如printf()）接受可变数量的参数。头文件stdvar.h提供了创建用户自定义的带可变数量参数的函数的工具。实现思想就是宏定义中参数列表的最后一个参数为省略号，预定义宏\__VA_ARGS__就可以被用在替换部分中，以表明省略了什么。
	
	```
	#define PR(...) printf(__VA_ARGS__)
	//调用
	PR("Howdy");
	//__VA_ARGS__展开为一个参数"Howdy"
	//展开后printf("Howdy");
	PR("weight = %d, shipping = %.2f\n", wt, sp);
	//__VA_ARGS__展开为三个参数
	//展开后printf("weight = %d, shipping = %.2f\n", wt, sp);	
	```
	```
	#include <stdio.h>
	#include <math.h>
	#define PR(X, ...) printf("Message " #X ": " __VA_ARGS__)
	int main(void)
	{
		double x = 48;
		double y;
		
		y = sqrt(x);
		PR(1, "x = %g\n", x);
		PR(2, "x = %.2f, y = %.4f\n", x, y);
		
		return 0;	
	}
	```
	
### 4. 宏，还是函数

1. 宏在某种程度上比函数复杂。通常，编译器限制宏只能定义成一行。

2. 宏与函数间的选择实际上是时间与空间之间的权衡。宏产生内联代码，在程序中产生语句，重复拷贝。而函数只有一份拷贝，节省了空间，但函数的控制必须转移到函数中并随后返回调用程序，比内联代码耗费时间。

3. 宏的一个优点是不检查其中的变量类型，因为宏处理字符型字符串，而不是实际值。

4. C99提供了第三种方法：内联函数。

### 5. 文件包含：#include

1. **\#include**指令的两种使用形式：
	```
	#include <stdio.h>
	//预处理器在一个或多个标准系统目录中寻找文件。
	#include "mystuff.h"
	//预处理器先在当前目录（或文件名中指定的其他目录）中寻找文件，然后在标准系统目录中寻找文件。
	#include "/usr/biff/p.h"
	//搜索/usr/biff目录	
	```
	注：
	(1)对于系统头文件，集成开发环境（IDE）具有标准搜索路径。许多IDE提供菜单选项用于指定使用尖括号时搜索的其他路径。对于UNIX，使用双引号时首先搜索本地目录，但是具体搜索哪个目录依赖于编译器。有些编译器搜索源代码文件所在目录，有些搜索当前工作目录，有些搜索工程文件所在目录。
	(2)包含大型头文件并不一定显著增加程序的大小，通常，头文件中的内容是编译器产生最终代码所需的信息，而不是加到最终代码里的具体语句。

2. 使用const可以避免值被恶意修改。使用static后，每个包含该头文件的文件都获得一份该常量的副本，该变量具有文件作用域，内部链接。而具有文件作用域、外部链接的变量，需要在一个文件中进行定义声明，而在其他文件中进行引用声明。
	```
	//可以在包含函数声明的源代码文件中定义一个具有文件作用域、外部链接的变量
	int status = 0;//文件作用域，外部链接
	//然后，在与源代码文件相关联的头文件中进行引用声明
	extern int status;//头文件中
	```

### 5. 其他指令

1. **#undef**：取消定义一个给定的#define
	```
	#define LIMIT 40
	//取消定义
	#undef LIMIT
	//重新定义
	#define LIMIT 100
	```
	注：如果想使用一个特定名字，但又不能确定前面是否已经使用了该名字，为安全起见，可以取消该名字定义。

2. 已定义：C预处理器的观点
预处理器在预处理指令中遇到标识符时，要么把标识符当作已定义（由预处理器定义）的，要么当作未定义的。如果标识符是该文件前面#define指令创建的宏名，并且没有使用#undef指令关闭该标识符，则标识符是已定义的。如果标识符不是宏，而是一个具有文件作用域的C变量，那么预处理把标识符当作未定义的。
	
	```
	#define LIMIT 1000//LIMIT已定义
	#define GOOD//GOOD已定义
	#define A(X) ((-(X)) * (X))//A已定义
	int q;//q不是一个宏，是未定义的
	#undef GOOD//GOOD是未定义的
	```
	注：#define宏的作用域从文件中的定义点开始，直到用#undef指令取消宏为止，或直到文件尾为止（由二者中最先满足的那个结束宏的作用域）。如果用头文件引入宏，#define在文件中的位置依赖于#include指令的位置

3. 条件编译
	- **\#ifdef**、**#else**、**#endif**指令：
	```
	#ifdef MAVIS
		#include "horse.h"
		#define STABLES 5
	#else
		#include "cow.h"
		#define STABLES 15
	#endif
	```
		注：这些条件结构可以嵌套，也可以用这些指令标记C语句块（如使用#ifdef选择适用于不同C实现的大块代码）。如：
	```
	#ifdef DEBUG
		printf("OK!");
	#endif
	```
	- **\#ifndef**指令：#ifndef指令也可以与#else、#endif指令一起使用。#ifndef判断后面的标识符是否为未定义的。如：
	```
	#ifndef SIZE
		#define SIZE 100
	#endif
	```
		注：
		(1)旧的编译器不允许使用缩排格式的#define指令，必须左对齐。
		(2)当包含多个头文件时，使用#ifndef可以防止对某个宏重复定义。
		(3)#ifndef指令通常用于防止多次包含同一文件。
		
		```
		/*  things.h  */
		#ifndef THINGS_H_
			#define THINGS_H_
			/*  头文件其他部分  */
		#endif			
		```
		(4)标准C头文件使用#ifndef技术来避免多次包含。通常用文件名做标识符，并在文件名中使用大写字母、下划线代替文件名中的句点字符、用下划线（可能使用两条下划线）做前缀或后缀。例如：
		
		```
		#ifndef _STDIO_H
		#define _STDIO_H
		//文件内容
		#endif
		```
	- **\#if**和**#elif**指令：#if后跟常量整数表达式。如果表达式为非零值，则表达式为真。在该表达式中可以使用C的关系运算符和逻辑运算符。如：
	```
	//#if
	#if SYS == 1
	#include "ibm.h"
	#endif
	//#elif	
	#if SYS == 1
		#include "ibmpc.h"
	#elif SYS == 2
		#include "vax.h"
	#elif SYS == 3
		#include "mac.h"
	#else
		#include "general.h"
	#endif
	```
	- **defined**预处理器运算符：如果defined的参数已用#define定义过，那么defined返回1，否则返回0。这种方法可以和#elif一起使用。
	```
	#if defined(IBMPC)
		#include "ibmpc.h"
	#elif defined(VAX)
		#include "vax.h"
	#elif defined(MAC)
		#incldue "mac.h"
	#else
		#include "general.h"
	#endif
	```
		注：条件编译的一个用途是可以使程序更易于移植。

4. 预定义宏
	- **\__DATA__**：返回预处理的日期（“mm dd yyyy"形式的字符串文字）。
	- **\__TIME__**：源文件编译时间，格式为"hh:mm:ss"。
	- **\__func__**：代表函数名的字符串。（**该标识符具有函数作用域，而宏本质上具有文件作用域。因而“\__func__"是C语言的预定义标识符，而不是预定义宏**）
	- **\__FILE__**：代表当前源文件名的字符串文字。
	- **\__LINE__**：代表当前源代码文件中的行号的整数常量。
	- **\__STDC__**：设置为1时，表示该实现遵循C标准。
	- **\__STDC_HOSTED__**：为本机环境设置为1，否则设置为0。
	- **\__STDC_VERSION__**：为C99时设置为199901L，编译时需加**-std=c9x**

5. **#line**和**#error**
	- **#line**指令用于重置由**\__LINE__**和**\__FILE__**宏报告的行号和文件名。
	```
	#line 1000 //把当前行号重置为1000	
	#line 10 "cool.c" //把行号重置为10， 文件名重置为cool.c
	```
	- **#error**指令使预处理器发出一条错误信息，该消息包含指令中的文本。
	```
	#if __STDC_VERSION__ != 199901L
		#error Not C99
	#endif
	```

6. **#pragma**
	- 在现代编译器中，可用命令行参数或者IDE菜单选项修改编译器的某些设置，也可用#pragma将编译器指令置于源代码中。	
	```
	#pragma c9x on //启用对C9X的支持	
	```
	- **\_Pragma**预处理器运算符：可将字符串转换成常规的编译指示。
	```
	_Pragma("nonstandardtreatmenttypeB on")
	//等价于
	#pragma nonstandardtreatmenttypeB on
	```
		注：也可将该运算符作为宏展开的一部分
	```
	#define PRAGMA(X) _Pragma(#X)
	//下面用法有缺陷，下面的代码依赖于字符串连接功能，但是直到预处理过程完成后编译器才连接字符串
	#define LIMRG(X) PRAGMA(STDC CX_LIMITED_RANGE X)
	```

### 6. 内联函数

1. 使用类函数宏的一个原因就是可减少执行时间。内联函数也可减少函数调用等开销。

2. 把函数变为内联函数将**建议**编译器尽可能快速地调用该函数。但是具体效果由实现来定义，因此使函数变为内联函数可能会简化函数的调用机制（用函数体替换函数调用），也可能不起作用。

3. 创建内联函数的方法是在函数声明中使用函数说明符inline。
	```
	#include <stdio.h>
	inline void eatline()
	{
		while (getchar() != '\n')
		{
			continue;
		}
	}
	int main(void)
	{
		......
		eatline(); //函数调用
		......
	}
	```
	注：
	(1)无法获得内联函数的地址，因为内联函数没有预留的单独代码块。
	(2)内联函数不会在调试器中显示。
	(3)内联函数应该短小，对于较长的函数，使用内联函数不会节省太多时间。
	(4)编译器在优化内联函数时，必须知道函数定义的内容。因此内联函数的定义和对该函数的调用必须在同一个文件中（内联函数通常具有内部链接）。通常，在头文件中定义内联函数，并在使用该函数的文件中包含该头文件。一般不再头文件中放置函数定义，但内联函数是个例外。
	(5)与C++不同，C允许混合使用内联函数定义和外部函数定义（具有外部链接的函数定义）。
	(6)C还允许在包含内联函数定义的文件中放置外部函数声明。
	```
	//file1b.c
	......
	extern double square(double); //把square()声明为外部函数
	inline double square(double); //把square()声明为内联函数
	double square(double x) { return x * x;}
	
	int main(void)
	{
		......
		double q = square(1.3) + square(1.5);
		......
	}
	//file2b.c
	extern double square(double);
	double square(double x) 
	{
		int y;
		y = x * x;
		return y;
	}
	//在file1b.c对square()的调用中，编译器可随意使用该函数的内部定义和外部定义，甚至两次调用所使用的定义可以不一致。
	```

### 7. C库

1. 头文件提供函数声明或原型，而库选项告诉系统到哪儿寻找函数代码。

2. size_t类型定义为sizeof运算符返回的无符号整数类型，通常为unsigned int或unsigned long。stddef.h文件中包含有size\_t类型的typedef或#define定义。

3. ANSI C使用指向void类型的指针作为通用指针。需要使用指向不同类型的指针时，可采用void指针。

### 8. 数学库

1. math.h提供这些数学函数的函数声明或原型。如：
	
	```
	double ceil (double x);//向上取整，返回不小于x的最小整数值
	double floor (double x);//向下取整， 返回不大于x的最大整数值
	```
	注：UNIX/Linux系统要求使用**"-lm"**标记以指示连接器搜索数学库。

### 9. 通用工具库

1. 通用工具库包含各种函数：随机数产生函数、搜索和排序函数、转换函数和内存管理函数。这些函数的原型在头文件**stdlib.h**中。

2. **exit()**和**atexit()**函数：
	- **atexit()**函数：只需把要调用的函数地址（函数指针）传递给atexit()。atexit()把作为其参数的函数在调用exit()时执行的函数列表中进行注册。ANSI保证该列表至少可放置32个函数。最优调用exit()函数时，按后进先出的顺序执行这些函数。
	注：由atexit()注册的函数类型为无参的void函数（通常它们执行内部处理任务，如更新程序监视文件或重置环境变量）。
	- **exit()**函数：exit()函数执行了atexit()指定的函数后，会做一些自身清理巩固总。它会刷新所有输出流、关闭所有的流，并关闭通过调用标准I/O函数tmpfile()创建的临时文件，最后把控制返回给主机环境，向主机环境报告终止状态（**EXIT_SUCCESS**(0)表示成功终止，**EXIT_FAILURE**(非0)表示失败）。

3. **qsort()**函数：对数据对象数组进行排序。
	```
	void qsort (void *base, size_t nmemb, size_t size, int (*compar) (const void *, const void *));//函数原型
	```

4. **C**和**C++**中的**void \***
C和C++对待void类型的指针是不同的。都可以把一个指向任意类型的指针赋给类型**void \***。但是在把一个**void \***指针赋给一个指针或者另一个类型的时候，C++需要一次强制类型转换，而C没有这个要求。

	```
	const double * a1 = (const double *) p1;
	```

### 10. 诊断库

1. 由头文件**assert.h**支持的诊断库用于辅助调试程序，由宏**assert()**构成，该宏接受整数表达式作为参数。
	- 如果表达式值为假（非零），宏**assert()**向标准错误流（stderr）写入一条错误消息并调用abort()函数终止程序。
	- **assert()**宏的作用：标识出程序中某个条件应为真的关键位置，并在条件为假时用**assert()**语句终止该程序。通常，**assert()**的参数为关系或逻辑表达式。如果**assert()**终止程序，首先会显示失败的判断、包含该判断的文件名和行号。**assert()**能自动识别文件，并自动识别发生问题的行号。

2. 无需改变代码就能开启或禁用**assert()**宏的机制：
在**assert.h**包含语句所在位置前添加宏定义**#define NDEBUG**，并重新编译程序。编译器将禁止文件中所有的**assert()**语句。如果程序出现问题，可以去除**#define NDEBUG**指令重新编译，重新启用**assert()**语句。

### 11. **memcpy()**和 **memmove()**

1. 不能把一个数组的值直接赋给另一个数组，但是**memcpy()**和**memmove()**函数能方便地复制数组。	
	
	```
	void *memcpy (void * restrict s1, const void * restrict s2, size_t n);
	void *memmove (void * s1, const void * s2, size_t n);
	```
	注：
	(1)两个函数均从s2指向位置复制n字节数据到s1指向的位置，且均返回s1的值。
	(2)两者差别：由关键字**restrict**造成，**memcpy()**可以假定两个内存区域之间没有重叠。**memmove()**函数则不作这个假定。**使用memcpy()时，必须确保源、目的内存没有重叠区域**

### 12. 可变参数：**stdargs.h**

1. 使用方法：
	- 在函数原型中使用省略号。
	```
	void f1(int n, ...);
	int f2(int n, const char * s, ...);
	char f3 (char c1, ..., char c2); //无效
	double f3(); //无效
	```
		注：可变函数参数列表最右边的参量有特殊作用（ANSI标准用parmN表示该参量），该参量的实际参数值将是省略号部分代表的参数个数。
	- 在函数定义中创建一个**va_list**类型的变量。可变函数定义的起始部分如下：	
	```
	double sum (int lim, ...)
	{
		va_list ap; //声明用于存放参数的变量
		......
	}
	//lim用来指定可变参数列表中的参数个数
	```
		注：头文件**stdargs.h**中声明的**va_list**类型代表一种数据对象，该数据对象用于存放参量列表中省略号部分代表的参量。
	- 用宏将该变量初始化为一个参数列表。使用**stdargs.h**中定义的宏**va_start()**把参数列表复制到**va_list**变量中。
	```
	va_start (ap, lim); //把ap初始化为参数列表
	```
		注：宏**va_start()**有两个参数，**va_list**类型的变量和参量**parmN**。
	- 用宏访问这个参数列表。使用宏**va_arg()**。
	```
	double tic;
	int toc;
	......
	tic = va_arg(ap, double); //取得第一个参数
	toc = va_arg(ap, int); //取得第二个参数
	```
		注：
		(1)宏**va_art()**接受两个参数，**va_list**类型的变量和一个类型名。第一次调用**va_arg()**，返回参数列表的第一项，下次调用返回第二项，类型参数指定返回值的类型。
		(2)传入实际参数的类型必须与说明的类型相匹配，不会像赋值过程中一样类型自动转换。
	- 用宏完成清理工作。使用宏**va_end()**。
	```
	va_end(ap);//该宏接受一个va_list变量作为参数
	```

4. **va_arg()**不提供后退回先前参数的方法，所以保存**va_list**变量的副本会是有用的。可使用**va_copy()**。
	```
	va_list ap;
	va_list apcopy;
	double tic;
	int toc;
	......
	va_start(ap, lim);
	va_copy(apcopy, ap);
	tic = va_arg(ap, double);
	toc = va_arg(ap, int);
	//此时，虽然已从ap中删除了前面两项，但还可以从apcopy中重新获取这两项
	```

## 第17章 高级数据表示

### 1. 抽象数据类型（**ADT**）

1. 一个类型指定两类信息：一个属性集和一个操作集。

2. 定义新类型的方法：
	- 为类型的属性和可对类型执行的操作提供一个抽象的描述，称为**抽象数据类型（ADT）**。
	- 开发一个实现该ADT的编程接口。说明如何存储数据并描述用于执行所需操作的函数集合。
	- 编写代码实现这个接口。

3. 接口有两个部分：第一部分描述数据如何表示，第二部分描述实现ADT操作的函数。

4. 内部链接函数只在定义它的文件中可见。

5. 对于链表而言，列表的大小受可用内存数量限制。可以尝试为一个新节点分配内存（仅限于测试是否有可用内存），如果分配失败，则列表已满；如果分配成功，表示列表未满，释放刚刚分配的内存。

6. 数据隐藏：把实现和最终接口相隔离。

### 2. 链表与数组

1. 在链表中不能使用折半搜索。

2. 选择何种数据类型是取决于具体问题的。
	- 链表更适合于需要频繁地插入和删除元素，不断调整大小，并且不需要经常搜索的情形。
	- 数组更适合于只是偶尔插入或删除一些元素，但却需要经常搜索的情形。

### 3. 二叉搜索树

1. 二叉搜索树中元素唯一，不含有相同的元素。插入前要检查二叉搜索树中是否已存在待插入元素。

2. 二叉搜索树删除一个节点时，分三种情况：
	- 无左子节点的节点（无子节点的节点可以作为无左子节点的特例）。
	- 无右子节点的节点。
	- 有两个子节点的节点。
	
	```
	static void DeleteNode(Node **ptr)
	{
		Node * temp;
		
		puts((*ptr)->item.petname);
		if ((*ptr)->left == NULL)
		{
			temp = *ptr;
			*ptr = (*ptr)->right;
			free(temp);
		}
		else if ((*ptr)->right == NULL)
		{
			temp = *ptr;
			*ptr = (*ptr)->left;
			free(temp);
		}
		else //被删除节点有两个子节点
		{
			//找到右子树的依附位置，即待删除节点左子树的最右边的叶节点
			for (temp = (*ptr)->left; temp->right != NULL; temp = temp->right)
			{
				continue;
			}
			temp->right = (*ptr)->right;
			temp = *ptr;
			*ptr = (*ptr)->left;
			free(temp);
		}
	}
	```

3. 遍历树：
	```
	void Traverse (const Tree * ptree, void (* pfun) (Item item))
	{
		if (ptree != NULL)
		{
			InOrder(ptree->root, pfun);
		}
	}
	static void  InOrder (const Node * root, void (* pfun) (Item item))
	{
		if (root != NULL)
		{
			InOrder(root->left, pfun);
			(*pfun)(root->item);
			InOrder(root->right, pfun);
		}
	}
	```

4. 删除树：
	```
	void DeleteAll (Tree * ptree)
	{
		if (ptree != NULL)
		{
			DeleteAllNodes(ptree->root);
		}
		ptree->root = NULL;
		ptree->size = 0;
	}
	static void DeleteAllNodes (Node * root)
	{
		Node * pright;
		if (root != NULL)
		{
			pright = root->right;
			DeleteAllNodes(root->left);
			free(root);
			DeleteAllNodes(pright);
		}
	}
	```
